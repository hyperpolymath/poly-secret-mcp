// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Deno from "../bindings/Deno.res.js";
import * as Adapter from "../Adapter.res.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";

let vaultAddr = {
  contents: $$Deno.Env.getWithDefault("VAULT_ADDR", "http://127.0.0.1:8200")
};

let connected = {
  contents: false
};

async function runVaultCmd(args) {
  return await $$Deno.Command.run("vault", args);
}

async function connect() {
  let match = await runVaultCmd([
    "status",
    "-format=json"
  ]);
  let code = match[0];
  if (code === 0 || code === 2) {
    connected.contents = true;
    return;
  } else {
    return Stdlib_Exn.raiseError("Failed to connect to Vault");
  }
}

async function disconnect() {
  connected.contents = false;
}

async function isConnected() {
  return connected.contents;
}

async function readHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = args["field"];
  let field = typeof match$1 === "string" ? match$1 : undefined;
  let cmdArgs = [
    "kv",
    "get",
    "-format=json"
  ];
  if (field !== undefined) {
    cmdArgs.push(`-field=` + field);
  }
  cmdArgs.push(path);
  let match$2 = await runVaultCmd(cmdArgs);
  let stdout = match$2[1];
  if (match$2[0] !== 0) {
    return Stdlib_Exn.raiseError(match$2[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "value",
        stdout.trim()
      ]]);
  }
}

async function writeHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = args["data"];
  let dataPairs;
  if (match$1 !== undefined) {
    if (Array.isArray(match$1)) {
      dataPairs = Stdlib_Array.filterMap(match$1, x => {
        if (typeof x === "string") {
          return x;
        }
      });
    } else {
      switch (typeof match$1) {
        case "string" :
          dataPairs = match$1.split(" ");
          break;
        default:
          dataPairs = Stdlib_Exn.raiseError("data parameter is required (string 'key=val key2=val2' or array)");
      }
    }
  } else {
    dataPairs = Stdlib_Exn.raiseError("data parameter is required (string 'key=val key2=val2' or array)");
  }
  let cmdArgs = [
    "kv",
    "put",
    "-format=json",
    path
  ];
  dataPairs.forEach(pair => {
    cmdArgs.push(pair);
  });
  let match$2 = await runVaultCmd(cmdArgs);
  if (match$2[0] !== 0) {
    return Stdlib_Exn.raiseError(match$2[2]);
  }
  try {
    return JSON.parse(match$2[1]);
  } catch (exn) {
    return Object.fromEntries([[
        "success",
        true
      ]]);
  }
}

async function deleteHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = args["versions"];
  let versions = Array.isArray(match$1) ? Stdlib_Array.filterMap(match$1, x => {
      if (typeof x === "number") {
        return x | 0;
      }
    }) : undefined;
  let cmdArgs = versions !== undefined ? [
      "kv",
      "delete",
      "-versions=" + versions.map(n => n.toString()).join(","),
      path
    ] : [
      "kv",
      "delete",
      path
    ];
  let match$2 = await runVaultCmd(cmdArgs);
  if (match$2[0] === 0) {
    return Object.fromEntries([[
        "success",
        true
      ]]);
  } else {
    return Stdlib_Exn.raiseError(match$2[2]);
  }
}

async function listHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = await runVaultCmd([
    "kv",
    "list",
    "-format=json",
    path
  ]);
  let stdout = match$1[1];
  if (match$1[0] !== 0) {
    return Stdlib_Exn.raiseError(match$1[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "keys",
        stdout
      ]]);
  }
}

async function metadataHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = await runVaultCmd([
    "kv",
    "metadata",
    "get",
    "-format=json",
    path
  ]);
  let stdout = match$1[1];
  if (match$1[0] !== 0) {
    return Stdlib_Exn.raiseError(match$1[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "metadata",
        stdout
      ]]);
  }
}

async function statusHandler(_args) {
  let match = await runVaultCmd([
    "status",
    "-format=json"
  ]);
  let stdout = match[1];
  let code = match[0];
  if (code !== 0 && code !== 2) {
    return Stdlib_Exn.raiseError(match[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "status",
        stdout
      ]]);
  }
}

async function enginesHandler(_args) {
  let match = await runVaultCmd([
    "secrets",
    "list",
    "-format=json"
  ]);
  let stdout = match[1];
  if (match[0] !== 0) {
    return Stdlib_Exn.raiseError(match[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "engines",
        stdout
      ]]);
  }
}

async function generateHandler(args) {
  let match = args["path"];
  let path = typeof match === "string" ? match : Stdlib_Exn.raiseError("path parameter is required");
  let match$1 = await runVaultCmd([
    "read",
    "-format=json",
    path
  ]);
  let stdout = match$1[1];
  if (match$1[0] !== 0) {
    return Stdlib_Exn.raiseError(match$1[2]);
  }
  try {
    return JSON.parse(stdout);
  } catch (exn) {
    return Object.fromEntries([[
        "credentials",
        stdout
      ]]);
  }
}

let tools = Object.fromEntries([
  [
    "vault_read",
    {
      description: "Read a secret from Vault KV store",
      params: Object.fromEntries([
        [
          "path",
          Adapter.stringParam("Secret path (e.g., secret/data/myapp)")
        ],
        [
          "field",
          Adapter.stringParam("Specific field to retrieve (optional)")
        ]
      ]),
      handler: readHandler
    }
  ],
  [
    "vault_write",
    {
      description: "Write a secret to Vault KV store",
      params: Object.fromEntries([
        [
          "path",
          Adapter.stringParam("Secret path (e.g., secret/data/myapp)")
        ],
        [
          "data",
          Adapter.stringParam("Secret data object (JSON)")
        ]
      ]),
      handler: writeHandler
    }
  ],
  [
    "vault_delete",
    {
      description: "Delete a secret from Vault",
      params: Object.fromEntries([
        [
          "path",
          Adapter.stringParam("Secret path")
        ],
        [
          "versions",
          Adapter.stringParam("Specific versions to delete (array of numbers)")
        ]
      ]),
      handler: deleteHandler
    }
  ],
  [
    "vault_list",
    {
      description: "List secrets at a path",
      params: Object.fromEntries([[
          "path",
          Adapter.stringParam("Path to list (e.g., secret/metadata/)")
        ]]),
      handler: listHandler
    }
  ],
  [
    "vault_metadata",
    {
      description: "Get secret metadata including versions",
      params: Object.fromEntries([[
          "path",
          Adapter.stringParam("Secret path")
        ]]),
      handler: metadataHandler
    }
  ],
  [
    "vault_status",
    {
      description: "Get Vault server status",
      params: {},
      handler: statusHandler
    }
  ],
  [
    "vault_engines",
    {
      description: "List all secret engines",
      params: {},
      handler: enginesHandler
    }
  ],
  [
    "vault_generate",
    {
      description: "Generate dynamic credentials from a secrets engine",
      params: Object.fromEntries([[
          "path",
          Adapter.stringParam("Credentials path (e.g., database/creds/myapp)")
        ]]),
      handler: generateHandler
    }
  ]
]);

let name = "vault";

let description = "HashiCorp Vault secrets management adapter";

export {
  vaultAddr,
  connected,
  name,
  description,
  runVaultCmd,
  connect,
  disconnect,
  isConnected,
  readHandler,
  writeHandler,
  deleteHandler,
  listHandler,
  metadataHandler,
  statusHandler,
  enginesHandler,
  generateHandler,
  tools,
}
/* vaultAddr Not a pure module */
